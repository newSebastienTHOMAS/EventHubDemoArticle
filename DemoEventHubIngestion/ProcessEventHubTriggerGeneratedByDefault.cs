using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using DemoEventHubIngestion.Model;
using DemoEventHubIngestion.Service;
using Microsoft.ApplicationInsights;
using Microsoft.ApplicationInsights.DataContracts;
using Microsoft.ApplicationInsights.Extensibility;
using Microsoft.Extensions.Logging;
using Newtonsoft.Json;

namespace DemoEventHubIngestion
{

    /// <summary>
    /// This Code is for demonstration Only.
    /// It is the Event Hub Processor code that is generated by visual Studio with only telemetry added to visualize the process delay
    /// </summary>
    public class ProcessEventHubTriggerGeneratedByDefault
    {
        private readonly TelemetryClient _clientTMetry;
        private readonly ILogger<ProcessEventHubTriggerGeneratedByDefault> _logger;
        private readonly IProcessMessage _processMessage;

        public ProcessEventHubTriggerGeneratedByDefault(TelemetryConfiguration configuration,
                                                    ILogger<ProcessEventHubTriggerGeneratedByDefault> log,
                                                    IProcessMessage processMessage)
        {
            _clientTMetry = new TelemetryClient(configuration);
            _logger = log;
            _processMessage = processMessage;
        }

        // For demo purposes: here is the code of the Visual Studio implementation of an Event Hub Ingest trigger with Telemetry

        //[FunctionName("ProcessEventHubTriggerGeneratedByDefault")]
        //public async Task Run([EventHubTrigger("%eventHubEntityName%", Connection = "eventHubConnectionString")] EventData[] events)
        //{
        //    var exceptions = new List<Exception>();

        //    var timeStart = DateTime.Now;
        //    var id = Guid.NewGuid().ToString();
        //    var nbExceptions = 0;
        //    var NbMessages = events.Length;

        //    foreach (EventData eventData in events)
        //    {
        //        try
        //        {
        //            string messageBody = eventData.EventBody.ToString();

        //            // Replace these two lines with your processing logic.
        //            _processMessage.ProcessEventHubRequest(messageBody);                    
        //        }
        //        catch (Exception e)
        //        {
        //            // We need to keep processing the rest of the batch - capture this exception and continue.
        //            // Also, consider capturing details of the message that failed processing so it can be processed again later.
        //            exceptions.Add(e);
        //            nbExceptions++;
        //        }
        //    }

        //    // Telemetry
        //    var timeEnd = DateTime.Now;
        //    var elapsedtime = timeEnd.Subtract(timeStart);


        //    var evt = new EventTelemetry();
        //    evt.Name = "Process Events Batch Runner";
        //    evt.Properties["Batch Id"] = id;
        //    // /1000 => to get in seconds
        //    evt.Metrics["Messages Average Latency"] = (elapsedtime.TotalMilliseconds / NbMessages) / 1000;

        //    evt.Metrics["Messages Success"] = NbMessages - nbExceptions;
        //    evt.Metrics["Messages Exceptions"] = nbExceptions;

        //    evt.Metrics["Messages Total"] = NbMessages;
        //    evt.Metrics["Batch Elapsed Time"] = ((TimeSpan)elapsedtime).TotalMilliseconds;

        //    _clientTMetry.TrackEvent(evt);


        //    // Once processing of the batch is complete, if any messages in the batch failed processing throw an exception so that there is a record of the failure.
        //    if (exceptions.Count > 1)
        //        throw new AggregateException(exceptions);

        //    if (exceptions.Count == 1)
        //        throw exceptions.Single();
        //}


    }
}
